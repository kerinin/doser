# TODO: Human-readable names for resources

schema {
  query: Query
  mutation: Mutation
}

type Query {
  firmatas: [Firmata!]
  pumps: [Pump!]
  water_level_sensors: [WaterLevelSensor!]
  auto_top_off: [AutoTopOff!]
  auto_water_changes: [AutoWaterChange!]
  dosers: [Doser!]
}

# Firmata microcontroller device configuration
type Firmata {
  id: ID!
  pumps: [Pump!]

  # The serial port on the host system, ie /dev/tty...
  serial_port: String!
  # The serial connection baud rate to use
  baud: Int!
}

# A pump driven via the AccelStepperFirmata protocol
type Pump {
  id: ID!
  firmata: Firmata!
  # The device ID used for controlling firmata
  device_id: Int!
  # The pin to use for the step signal
  step_pin: Int!
  # The pin to use for the engage signal, if used
  en_pin: Int
  # The pump's volume calibration
  calibration: TwoPointCalibration
}

type TwoPointCalibration {
  # The number of steps pumped for the calibration run
  steps: Int!
  # The volume measured after the calibration run in mL
  volume: Float!
}

enum SensorKind {
  # High-water level sensor
  HIGH
  # Alert sensor
  ALERT
}

type WaterLevelSensor {
  id: ID!
  # The pin to use for the sensor. 
  # The pin is assumed to be a digital input. A HIGH value indicates the
  # presence of water.
  pin: Int!
  # The kind of sensor
  kind: SensorKind!
  water_detected: Boolean!
}

type AutoTopOff {
  id: ID!
  pump: Pump!
  # Water level sensors to use when topping off.
  # Sensors of kind LOW will trigger an top off run if their value changes from HIGH to LOW
  # Sensors of kind HIGH will terminate a top off run when their value chagnes from LOW to HIGH
  # Sensors of kind ALERT will terminate a top off run and cause an alert if their value chagnes from LOW to HIGH
  level_sensors: [WaterLevelSensor!]!
  # The rate in mL/s to pump during top off runs
  fill_rate: Float!
  # How frequently top off runs should be scheduled.
  # Uses standard cron tab formatting.
  fill_frequency: String
  # The maximum volume in mL to fill in a single run.
  # Causes an alert if this volume is exceeded
  max_fill_volume: Float
}

type AutoWaterChange {
  id: ID!
  fresh_pump: Pump!
  waste_pump: Pump!
  # The rate in L/day to exchange (each pump will deliver this many liters each day)
  exchange_rate: Float!
}

type Doser {
  id: ID!
  components: [DoserComponent!]
}
type DoserComponent {
  pump: Pump!
  # The rate to dose in mL/day
  dose_rate: Float!
}

type Mutation {
  createFirmata(serial_port: String!, baud: Int!): Firmata!
  deleteFirmata(id: ID!): Boolean!

  createPump(firmata_id: ID!, device_ID: ID!, step_pin: Int!, dir_pin: Int, en_pin: Int): Pump!
  deletePump(id: ID!): Boolean!

  calibratePump(pump_id: ID!, steps: Int!, volume: Float!): TwoPointCalibration!

  createWaterLevelSensor(pin: Int!, kind: SensorKind!): WaterLevelSensor!
  deleteWaterLevelSensor(id: ID!): Boolean!

  createAutoTopOff(pump_id: ID!, level_sensors: [ID!]!, fill_rate: Float!, fill_frequency: String!, max_fill_volume: Float!): AutoTopOff!
  deleteAutoTopOff(id: ID!): Boolean!

  createAutoWaterChange(fresh_pump_id: ID!, waste_pump_id: ID!, exchange_rate: Float!): AutoWaterChange!
  deleteAutoWaterChange(id: ID!): Boolean!

  createDoser(input: DoserInput!): Doser!
  deleteDoser(id: ID!): Boolean!

  pump(pump_id: ID!, steps: Int!, speed: Float!): Boolean!
}

input DoserInput {
  components: [DoserComponentInput!]!
}

input DoserComponentInput {
  pump_id: ID!
  dose_rate: Float!
}
