# TODO: Human-readable names for resources

schema {
  query: Query
  mutation: Mutation
}

type Query {
  firmatas: [Firmata!]
  pumps: [Pump!]
  water_level_sensors: [WaterLevelSensor!]
  auto_top_off: [AutoTopOff!]
  auto_water_changes: [AutoWaterChange!]
  dosers: [Doser!]
}

# Firmata microcontroller device configuration
type Firmata {
  id: ID!
  pumps: [Pump!]

  # The serial port on the host system, ie /dev/tty...
  serial_port: String!
  # The serial connection baud rate to use
  baud: Int!
}

# A pump driven via the AccelStepperFirmata protocol
type Pump {
  id: ID!
  firmata: Firmata!
  # The device ID used for controlling firmata
  device_id: Int!
  # The pin to use for the step signal
  step_pin: Int!
  # The pin to use for the engage signal, if used
  en_pin: Int
  # The pump's volume calibration
  calibration: TwoPointCalibration
  # Acceleration to use when changing pump speed, in steps/s/s
  acceleration: Float
}

type TwoPointCalibration {
  # The number of steps pumped for the calibration run
  steps: Int!
  # The volume measured after the calibration run in mL
  volume: Float!
}

enum SensorKind {
  # High-water level sensor
  HIGH
  # Alert sensor
  ALERT
}

type WaterLevelSensor {
  id: ID!
  # If present, the sensor is assumed to be attached to a firmata device
  firmata_id: ID
  # The pin to use for the sensor. 
  # The pin is assumed to be a digital input. A HIGH value indicates the
  # presence of water.
  # 
  # The pin number refers to the pinout number, and is in the range 1-40
  # Unfortunately, the Arduino shield labels these pins using the GPIO*
  # values. Executing `pinout` on the rPi will provide a mapping between
  # pins and labels.
  pin: Int!
  # The kind of sensor
  kind: SensorKind!
  water_detected: Boolean!
  # If present, the configured pin is assumed to be an analog input. Water 
  # is detected if the pin's voltage is greater than the given value
  detection_threshold: Int
}

type AutoTopOff {
  id: ID!
  pump: Pump!
  # Water level sensors to use when topping off.
  # Sensors of kind LOW will trigger an top off run if their value changes from HIGH to LOW
  # Sensors of kind HIGH will terminate a top off run when their value chagnes from LOW to HIGH
  # Sensors of kind ALERT will terminate a top off run and cause an alert if their value chagnes from LOW to HIGH
  level_sensors: [WaterLevelSensor!]!
  # The rate in mL/min to pump during top off runs
  fill_rate: Float!
  # The interval in minutes between scheduled top off runs.
  fill_interval: Int!
  # The maximum volume in mL to fill in a single run.
  # Causes an alert if this volume is exceeded
  max_fill_volume: Float

  events: [AutoTopOffEvent!]
}

type AutoWaterChange {
  id: ID!
  fresh_pump: Pump!
  waste_pump: Pump!
  # The rate in L/day to exchange (each pump will deliver this many liters each day)
  exchange_rate: Float!

  events: [AutoWaterChangeEvent!]
}

type Doser {
  id: ID!
  components: [DoserComponent!]
}

type DoserComponent {
  pump: Pump!
  # The rate to dose in mL/day
  dose_rate: Float!
}

union AutoTopOffEvent = ATOJobComplete | ATOJobError | MaxFillVolumeError | WaterLevelAlert | UncontrolledPumpError

type ATOJobComplete {
  timestamp: Int!
  duration: Float!
  volume: Float!
}

type ATOJobError {
  timestamp: Int!
  error: String!
}

union AutoWaterChangeEvent = AWCStatus | AWCJobError | UncontrolledPumpError

type AWCStatus {
  timestamp: Int!
  duration: Float!
  fresh_volume: Float!
  waste_volume: Float!
}

type AWCJobError {
  timestamp: Int!
  error: String!
}

type MaxFillVolumeError {
  timestamp: Int!
}

type UncontrolledPumpError {
  timestamp: Int!
  pump_id: ID!
  error: String!
}

type WaterLevelAlert {
  timestamp: Int!
}
  

type Mutation {
  createFirmata(serial_port: String!, baud: Int!): Firmata!
  deleteFirmata(id: ID!): Boolean!

  createPump(firmata_id: ID!, device_ID: Int!, step_pin: Int!, dir_pin: Int, en_pin: Int, acceleration: Float): Pump!
  updatePump(id: ID!, firmata_id: ID!, device_ID: Int!, step_pin: Int!, dir_pin: Int, en_pin: Int, acceleration: Float): Pump!
  deletePump(id: ID!): Boolean!

  calibratePump(pump_id: ID!, steps: Int!, volume: Float!): TwoPointCalibration!

  createWaterLevelSensor(pin: Int!, kind: SensorKind!, firmata_id: ID, detection_threshold: Int): WaterLevelSensor!
  updateWaterLevelSensor(id: ID!, pin: Int!, kind: SensorKind!, firmata_id: ID, detection_threshold: Int): WaterLevelSensor!
  deleteWaterLevelSensor(id: ID!): Boolean!

  createAutoTopOff(pump_id: ID!, level_sensors: [ID!]!, fill_rate: Float!, fill_interval: Int!, max_fill_volume: Float!): AutoTopOff!
  updateAutoTopOff(id: ID!, pump_id: ID!, level_sensors: [ID!]!, fill_rate: Float!, fill_interval: Int!, max_fill_volume: Float!): AutoTopOff!
  deleteAutoTopOff(id: ID!): Boolean!

  createAutoWaterChange(fresh_pump_id: ID!, waste_pump_id: ID!, exchange_rate: Float!): AutoWaterChange!
  deleteAutoWaterChange(id: ID!): Boolean!

  createDoser(input: DoserInput!): Doser!
  deleteDoser(id: ID!): Boolean!

  pump(pump_id: ID!, steps: Int!, speed: Float!): Boolean!
}

input DoserInput {
  components: [DoserComponentInput!]!
}

input DoserComponentInput {
  pump_id: ID!
  dose_rate: Float!
}
